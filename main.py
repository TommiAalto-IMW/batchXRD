import os
from tkinter import *
from tkinter import Label
from tkinter.filedialog import askopenfilenames
from tkinter.filedialog import askopenfilename
from tkinter.filedialog import asksaveasfile
from tkinter.filedialog import askopenfiles
from contextlib import redirect_stdout
from Atom import *
from Site import *
from Structure import *
from TextOut import *
import shutil
from tkinter.constants import *
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import time
import subprocess

filenames = None
outs_filenames = None
fenster = Tk()
numberRefined = 0
plots = []
plot_index = 0
inp_lines = None
sequential_var = BooleanVar()
reverse_var = BooleanVar()

def get_dpi(window):
    MM_TO_IN = 1 / 25.4
    pxw = window.winfo_screenwidth()
    inw = window.winfo_screenmmwidth() * MM_TO_IN
    return pxw / inw


def output(target, text):
    """
    used to print either to the console or to the text field in the tkinter window
    :param target: where to print
    :param text: what to print
    :return: nothing
    """
    with redirect_stdout(target) as nothing:
        print(text)


def is_float(string):
    try:
        float(string)
        return True
    except ValueError:
        return False


def process_prm(str1, str2):
    """
    This is used to check some entries in the .OUT files generated by refinement. Since these are somewhat inconsistend based on whether variable names are used
    or the value is refined or fixed. It works but not perfectly reliable
    :param str1:
    :param str2:
    :return:
    """
    value = None
    error = None
    if is_float(str1.split("`")[0]):
        value = float(str1.split("`")[0])
        if len(str1.split("`")) > 1:
            error = str1.split("`")[1].split("_")[1].split(",")[0].split(")")[0] if len(str1.split("`")[1].split("_")) > 1 else "no_error"
    elif str1[0] == "=":
        return str1.replace(";", ""), "no_error"
    elif is_float(str2.split("`")[0]):
        value = float(str2.split("`")[0])
        if len(str2.split("`")) > 1:
            error = str2.split("`")[1].split("_")[1].split(",")[0].split(")")[0] if len(str2.split("`")[1].split("_")) > 1 else "no_error"
    else:
        return "Variable Name " + str2, "no_error"
    return value, error

def process_prm_errors(str1, str2):
    """
    similar to process_prm, useed to deal with occurences of variables with and without errors. Works but not perfect
    :param str1:
    :param str2:
    :return:
    """
    if is_float(str1.split("`")[0]):
        return float(str1.split("`")[0]), str1.split("`")[1].split("_")[1].split(")")[0] if len(str1.split("`")[1].split("_")) > 1 else "no_error"
    elif is_float(str2.split("`")[0]):
        return float(str2.split("`")[0]), str2.split("`")[1].split("_")[1].split(")")[0] if len(str2.split("`")[1].split("_")) > 1 else "no_error"
    else:
        return "Variable_Name " + str2, "no_error"

def select_tc():
    """
    To let the user tell you where the tc.exe file is located
    """
    tc_textfield.delete(0, "end")
    tc_textfield.insert(0, askopenfilename(filetypes=[('exe files', '*.exe')]))
    with open("tcpath.txt", "w") as file:
        file.write(tc_textfield.get())


def select_action():
    global filenames
    filenames = askopenfilenames(filetypes=[('xy files', '*.xy')])
    print("selected files:")
    for filename in filenames:
        print(filename)
    selected_label.configure(text=str(len(filenames)) + " files selected")


def select_outs():
    global outs_filenames
    outs_filenames = askopenfilenames(filetypes=[('out files', '*.out')])
    print("selected files:")
    for name in outs_filenames:
        print(name)
    select_outs_label.configure(text=str(len(outs_filenames)) + " files selected")


def label_axes():
    plot.set_xlabel("2 theta / Â°", fontsize=5)
    plot.set_ylabel("counts per second", fontsize=5)
    plot.set_yticklabels(plot.get_ymajorticklabels(), fontsize=5)
    plot.set_xticklabels(plot.get_xmajorticklabels(), fontsize=5)


def redraw():
    plot.clear()
    plot.plot(plots[plot_index][0], plots[plot_index][1], linewidth=0.1)
    plot.plot(plots[plot_index][0], plots[plot_index][2], linewidth=0.1)
    plot.plot(plots[plot_index][0], plots[plot_index][3], linewidth=0.1)
    label_axes()
    canvas.draw()
    output(inp_field, str(plot_index))


def update_graph(event):
    """
    For making the left and right arrows work when the user wants to click through refinements
    """
    global plot_index
    try:
        if 0 <= int(number_entry.get()) < len(plots):
            plot_index = int(number_entry.get())
            redraw()
        else:
            number_entry.delete(0, "end")
            number_entry.insert(0, str(plot_index))
    except (TypeError, ValueError):
        output(inp_field, "please enter only integer numbers")


def move_right():
    global plot_index
    if plot_index < (len(plots) - 1):
        plot_index += 1
        number_entry.delete(0, "end")
        number_entry.insert(0, str(plot_index))
        redraw()


def move_left():
    global plot_index
    if plot_index > 0:
        plot_index -= 1
        number_entry.delete(0, "end")
        number_entry.insert(0, str(plot_index))
        redraw()


def button_process():
    """
    This function loops through .OUT files extracting all data and making a huge table containing all of it.
    Errors are not implemented yet for all variables, mostly atomic positions.
    This function is still buggy and does not work all the time, but it is essential because otherwise plotting the refinement results is a huge effort.
    In principle, it works by looking for the first word in every line and using it as a keyword for the values that follow. It mostly breaks down for the atoms.
    """
    files = []
    try:
        for filename in outs_filenames:
            print(filename)
            files.append(open(filename, "r"))
        output_file = asksaveasfile(mode="w", filetypes=[('txt files', '*.txt')], defaultextension=".txt")
    except TypeError:
        output(inp_field, "No files selected for processing!")
        return

    for ifile in range(0, len(outs_filenames)):
        lines = files[ifile].readlines()
        INPContent = []
        for line in lines:
            if line.strip() != "":
                INPContent.append(line.strip().split())
        readingStr = False
        Strs = []
        strIndex = -1
        for line in INPContent:
            if readingStr & (line[0] != "str"):
                match (line[0].split("(")[0]):
                    case "LVol_FWHM_CS_G_L":
                        Strs[strIndex].crystallite_size = float(line[2].split("`")[0].replace(",", ""))
                        if len(line[2].split("`")) > 1 and len(line[2].split("`")[1].split(",")[0].split("_")) > 1:
                            Strs[strIndex].crystallite_size_error = line[2].split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                    case "e0_from_Strain":
                        Strs[strIndex].strain = float(line[1].split("`")[0].split(",")[0])
                        if len(line[1].split("`")) > 1 and len(line[1].split("`")[1].split(",")[0].split("_")) > 1:
                            Strs[strIndex].strain_error = line[1].split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                    case "r_bragg":
                        Strs[strIndex].r_bragg = float(line[1].replace(",", ""))
                    case "phase_name":
                        Strs[strIndex].phase_name = line[1].split("\"")[1]
                    case "MVW":
                        Strs[strIndex].unit_cell_mass = float(line[1].split("`")[0].replace(",", ""))
                        Strs[strIndex].unit_cell_volume = float(line[2].split("`")[0].replace(",", ""))
                        if len(line[2].split("`")) > 1 and len(line[2].split("`")[1].split(",")[0].split("_")) > 1:
                            Strs[strIndex].unit_cell_volume_error = line[2].split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                        Strs[strIndex].weight_fraction_percent = float(line[3].split("`")[0].replace(",", ""))
                        if len(line[3].split("`")) > 1 and len(line[3].split("`")[1].split(",")[0].split("_")) > 1:
                            Strs[strIndex].weight_fraction_percent_error = line[3].split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                    case "space_group":
                        Strs[strIndex].space_group = line[1]
                    case "scale":
                        if(len(line) > 3):
                            Strs[strIndex].scale, Strs[strIndex].scale_error = process_prm(line[2].split("`")[0].replace(",", ""), line[3].split("`")[0].replace(",", ""))
                        else:
                            Strs[strIndex].scale = float(line[2].split("`")[0].replace(",", ""))
                    case "Phase_Density_g_on_cm3":
                        Strs[strIndex].density = float(line[1].split("`")[0].replace(",", "").replace(")", ""))
                    case "a":
                        Strs[strIndex].a, Strs[strIndex].a_error = process_prm_errors(line[1].split(",")[0], line[2].split(",")[0])
                    case "b":
                        Strs[strIndex].b, Strs[strIndex].b_error = process_prm_errors(line[1].split(",")[0], line[2].split(",")[0])
                    case "c":
                        Strs[strIndex].c, Strs[strIndex].c_error = process_prm_errors(line[1].split(",")[0], line[2].split(",")[0])
                    case "al":
                        Strs[strIndex].al, Strs[strIndex].al_error = process_prm_errors(line[1].split(",")[0], line[2].split(",")[0])
                    case "be":
                        Strs[strIndex].be, Strs[strIndex].be_error = process_prm_errors(line[1].split(",")[0], line[2].split(",")[0])
                    case "ga":
                        Strs[strIndex].ga, Strs[strIndex].ga_error = process_prm_errors(line[1].split(",")[0], line[2].split(",")[0])
                    case "Cubic":
                        current_line = "start"
                        for i in range(1, len(line)):
                            current_line = current_line + " " + line[i]
                        parameters_strings = current_line.split(",")
                        Strs[strIndex].a = float(parameters_strings[0].split()[1].split("`")[0])
                        if len(parameters_strings[0].split()[1].split("`")) > 1 and len(parameters_strings[0].split()[1].split("`")[1].split(",")[0].split("_")) > 1:
                            Strs[strIndex].a_error = parameters_strings[0].split()[1].split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                    case "Tetragonal" | "Hexagonal":
                        current_line = "start"
                        for i in range(1, len(line)):
                            current_line = current_line + " " + line[i]
                        parameters_strings = current_line.split(",")
                        print(current_line)
                        a_tetr_error = 0
                        c_tetr_error = 0
                        if parameters_strings[0].split()[1] == ":":
                            a_tetr = parameters_strings[0].split()[2].split("`")[0].split("_")[0].split(")")[0]
                            if len(parameters_strings[0].split()[2].split("`")) > 1 and len(parameters_strings[0].split()[2].split("`")[1].split("_")) > 1:
                                a_tetr_error = parameters_strings[0].split()[2].split("`")[1].split("_")[1].split(")")[0]
                        else:
                            a_tetr = parameters_strings[0].split()[1].split("`")[0].split("_")[0].split(")")[0]
                            if len(parameters_strings[0].split()[1].split("`")) > 1 and len(parameters_strings[0].split()[1].split("`")[1].split("_")) > 1:
                                a_tetr_error = parameters_strings[0].split()[1].split("`")[1].split("_")[1].split(")")[0]
                        if parameters_strings[1].split()[1] == ":":
                            c_tetr = parameters_strings[1].split()[2].split("`")[0].split("_")[0].split(")")[0]
                            if len(parameters_strings[1].split()[2].split("`")) > 1 and len(parameters_strings[1].split()[2].split("`")[1].split("_")) > 1:
                                c_tetr_error = parameters_strings[1].split()[2].split("`")[1].split("_")[1].split(")")[0]
                        else:
                            c_tetr = parameters_strings[1].split()[1].split("`")[0].split("_")[0].split(")")[0]
                            if len(parameters_strings[1].split()[1].split("`")) > 1 and len(parameters_strings[1].split()[1].split("`")[1].split("_")) > 1:
                                c_tetr_error = parameters_strings[1].split()[1].split("`")[1].split("_")[1].split(")")[0]

                        Strs[strIndex].a = a_tetr
                        Strs[strIndex].a_error = a_tetr_error
                        Strs[strIndex].c = c_tetr
                        Strs[strIndex].c_error = c_tetr_error
                        if line[0].split("(")[0] == "Hexagonal":
                            Strs[strIndex].ga = 120
                    case "Rhombohedral":
                        Strs[strIndex].a = float(line[1].split(",")[0].split("`")[0])
                        if len(line[1].split(",")[0].split("`")) > 1 and len(line[1].split(",")[0].split("`")[1].split(",")[0].split("_")) > 1:
                           Strs[strIndex].a_error = line[1].split(",")[0].split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                        Strs[strIndex].b = Strs[strIndex].a
                        Strs[strIndex].c = Strs[strIndex].a
                        Strs[strIndex].al = float(line[2].replace(")", "").split("`")[0])
                        if len(line[2].replace(")", "").split("`")) > 1 and len(line[2].replace(")", "").split("`")[1].split(",")[0].split("_")) > 1:
                            Strs[strIndex].al_error = line[2].replace(")", "").split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                        Strs[strIndex].be = Strs[strIndex].al
                        Strs[strIndex].ga = Strs[strIndex].al
                    case "Trigonal":
                        current_line = "@"
                        for i in range(1, len(line)):
                            current_line = current_line + " " + line[i]
                        parameters_strings = current_line.split(",")
                        Strs[strIndex].a = float(parameters_strings[0].split()[1].split("`")[0])
                        if len(parameters_strings[0].split()[1].split("`")) > 1 and len(parameters_strings[0].split()[1].split("`")[1].split(",")[0].split("_")) > 1:
                            Strs[strIndex].a_error = parameters_strings[0].split()[1].split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                        Strs[strIndex].c = float(parameters_strings[1].split()[1].split("`")[0])
                        if len(parameters_strings[1].split()[1].split("`")) > 1 and len(parameters_strings[1].split()[1].split("`")[1].split(",")[0].split("_")) > 1:
                            Strs[strIndex].c_error = parameters_strings[1].split()[1].split("`")[1].split(",")[0].split("_")[1].split(")")[0]
                        Strs[strIndex].ga = 120
                    case "site":
                        st = Site()
                        atomIndex = -1
                        atoms = []
                        for i in range(0, len(line)):
                            match (line[i]):
                                case "site":
                                    atomIndex = -1
                                    atoms = []
                                    st.site_label = line[i + 1]
                                case "num_posns":
                                    st.multiplicity = int(line[i + 1])
                                case "x":
                                    st.x, _ = process_prm(line[i + 1], line[i + 2])
                                case "y":
                                    st.y, _ = process_prm(line[i + 1], line[i + 2])
                                case "z":
                                    if len(line) > (i+2):
                                        st.z, _ = process_prm(line[i + 1], line[i + 2])
                                    else:
                                        st.z = float(line[i + 1].split("`")[0].replace(",", ""))
                                case "occ":
                                    atomIndex += 1
                                    atoms.append(Atom())
                                    atoms[atomIndex].formfactor = line[i + 1]
                                    atoms[atomIndex].occupation, _ = process_prm(line[i + 2], line[i + 3])
                                case "beq":
                                    atoms[atomIndex].beq, _ = process_prm(line[i + 1],
                                                                       (line[i + 2] if (
                                                                               len(line) > (i + 2)) else "Error"))
                        for atom in atoms:
                            st.add_atom(atom)
                        Strs[strIndex].add_site(st)
            if line[0] == "str":
                readingStr = True
                Strs.append(Structure())
                strIndex += 1
        header = ""
        data = ""
        for i in range(0, len(Strs)):
            header += "STRUCTURE" + str(i + 1) + "\t" + Strs[i].header + "\t"
            data += "STRUCTURE" + str(i + 1) + "\t" + Strs[i].data + "\t" + Strs[i].site_data + "\t"
        if (ifile == 0):
            output_file.write(header.strip() + "\n")
        output_file.write(data.strip() + "\n")
    for file in files:
        file.close()
    output_file.close()
    output(inp_field, str(len(outs_filenames)) + " .out files have been processed")
    output(inp_field, "A table containing all data has been saved to " + output_file.name)


def write_inp(filename):
    """
    Takes the inp file provided in the text field and writes it as TEMPLATE.inp to be used for refinements
    pk_grp described Peak Phases which will be removed since they produced errors
    xdd gives the location of the XRD pattern which will be overwritten with the file to be refined

    This function adds the functionality to the INP file to output the observed, calculated and difference curves for easy evaluation of the results afterwards
    :param filename: filename of the XRD pattern to be refined
    :return: nothing
    """
    for i in range(0, len(inp_lines)):
        if (inp_lines[i].strip().split(" ")[0] == "xdd"):
            inp_lines[i] = "xdd \"" + filename + "\""
        if (inp_lines[i].strip().split(" ")[0] == "pk_grp"):
            inp_lines[i] = ""
    inp = ""
    for line in inp_lines:
        inp += line + "\n"

    directory = ""
    try:
        partial_filename = filenames[0].split("/")
        for i in range(0, len(partial_filename) - 1):
            directory += partial_filename[i] + "/"
    except TypeError:
        print("No .xy file selected!")

    with open(directory + "TEMPLATE.inp", "w") as template_inp:
        template_inp.write(inp)
        template_inp.write("xdd_out testout.txt load out_record out_fmt out_eqn\n")
        template_inp.write("{\n")
        template_inp.write("\" %11.6f  \" = X;\n")
        template_inp.write("\" %11.6f  \" = Yobs;\n")
        template_inp.write("\" %11.6f  \" = Ycalc;\n")
        template_inp.write("\" %11.6f\\n\" = Yobs-Ycalc;\n")
        template_inp.write("}\n")
    return directory


def button_execute():
    """
    This runs the automated Rietveld refinement. It will pass a command to the command line to excecute tc.exe with a custom INP file made from the text in the text field
    and all the filenames selected beforehand. The resulting plots will be added to the lists for plotting later
    In case sequential refinement is selected, the result of the nth refinement will be the starting point for the (n+1)th refinement
    In case start from the last scan is selected, the refinement will run backwards. This is sometimes helpful in case the end result is very complex, since the user can
    define a INP file including complexity and the automated refinement only has to fade it out instead of finding the correct minimum.
    :return:
    """
    global plot_index
    global inp_lines
    inp_lines = inp_field.get("1.0", "end-1c").split("\n")

    inp_field.delete("1.0", "end-1c")

    tc_filename = tc_textfield.get()
    output(inp_field, "Location of tc.exe: " + tc_filename)

    for filename in (reversed(filenames) if reverse_var.get() else filenames):
        directory = write_inp(filename)
        inp_file = directory + "TEMPLATE.inp"
        try:
            os.system(tc_filename + " \"" + inp_file + "\"")
            print(tc_filename + " \"" + inp_file + "\"")
        except subprocess.CalledProcessError as e:
            # Print error details
            print(f"{e}")
            print(f"Command failed with return code {e.returncode}")
            print("Error message:", e.stderr)
            print("Output:", e.stdout)
        time.sleep(1)
        try:
            shutil.copy(directory + "TEMPLATE.out", filename.split(".")[0] + ".out")
            shutil.copy(directory + "testout.txt", filename.split(".")[0] + "_PLOT.txt")
        except FileNotFoundError as e:
            print(f"{e}")
        global numberRefined
        numberRefined += 1
        Erfolg_Label.configure(text="Refinements successful. Number of refinements: " + str(numberRefined))
        with open(filename.split(".")[0] + "_PLOT.txt", "r") as plot_file:
            lines = plot_file.readlines()
            two_theta = []
            y_obs = []
            y_calc = []
            y_difference = []
            for line in lines:
                two_theta.append(float(line.strip().split()[0]))
                y_obs.append(float(line.strip().split()[1]))
                y_calc.append(float(line.strip().split()[2]))
                y_difference.append(float(line.strip().split()[3]))
            plots.append([two_theta, y_obs, y_calc, y_difference])
            plot_index += 1
        if sequential_var.get():
            with open(directory + "TEMPLATE.out", "r") as out_file:
                lines = out_file.readlines()
                for i in range(len(lines)):
                    lines[i] = lines[i].replace("\n", "")
                inp_lines = []
                for line in lines:
                    if line.strip() != "" and line.split()[0] == "xdd_out":
                        break
                    else:
                        inp_lines.append(line)
    plot_index -= 1
    canvas.draw()
    redraw()
    number_entry.delete(0, "end")
    number_entry.insert(0, str(plot_index))

def load_plots():
    global plot_index
    global plots
    plots = []
    plot_index = 0
    plot_files = askopenfiles(title="load *_PLOT.txt files", filetypes=[('txt files', '*.txt')])
    for plot_file in plot_files:
        lines = plot_file.readlines()
        two_theta = []
        y_obs = []
        y_calc = []
        y_difference = []
        for line in lines:
            two_theta.append(float(line.strip().split()[0]))
            y_obs.append(float(line.strip().split()[1]))
            y_calc.append(float(line.strip().split()[2]))
            y_difference.append(float(line.strip().split()[3]))
        plots.append([two_theta, y_obs, y_calc, y_difference])
        plot_index += 1
        plot_file.close()
    plot_index -= 1
    canvas.draw()
    redraw()
    number_entry.delete(0, "end")
    number_entry.insert(0, str(plot_index))

# Den Fenstertitle erstellen
fenster.title("XRD Batch Processing")
fenster.geometry(str(fenster.winfo_screenwidth()) + "x" + str(fenster.winfo_screenheight()) + "+0+0")

top_frame = Frame(fenster)
top_frame.pack()

everything_frame = Frame(top_frame)
everything_frame.pack(side=LEFT)

tc_label = Label(everything_frame, text="Path to tc.exe file in TOPAS6 installation folder")
tc_label.pack()

tc_frame = Frame(everything_frame, width=100, height=1)
tc_frame.pack()
tc_button = Button(tc_frame, text="...", command=select_tc, width=20, height=1)
tc_textfield = Entry(tc_frame)
try:
    tc_textfield.insert(0, open("tcpath.txt", "r").readline())
except FileNotFoundError:
    print("no standard tc location specified")
tc_textfield.pack(side=LEFT)
tc_button.pack(side=RIGHT)

select_frame = Frame(everything_frame, width=100, height=1)
select_frame.pack()
anweisungs_label = Label(select_frame, text="Select .xy files to refine")
anweisungs_label.pack(side=LEFT)
select_button = Button(select_frame, text="Select Files", width=20, height=1, command=select_action)
select_button.pack(side=LEFT)
selected_label = Label(select_frame, text="0 files selected")
selected_label.pack(side=RIGHT)

inp_frame = Frame(top_frame)
inp_frame.pack(side=RIGHT)
inp_label = Label(inp_frame,
                  text="Paste the INP from a working fit you want to iterate here.")
inp_label.pack()
inp_field = TextOut(inp_frame, height=10,
                    width=100)
inp_field.pack()
excecute_frame = Frame(everything_frame, width=100, height=1)
sequential_checkbox = Checkbutton(excecute_frame, text="Sequential Fit", variable=sequential_var)
sequential_checkbox.pack(side=LEFT)
reverse_checkbox = Checkbutton(excecute_frame, text="start from the last scan", variable=reverse_var)
reverse_checkbox.pack(side=LEFT)
excecute_button = Button(excecute_frame, text="Excecute", command=button_execute)
excecute_button.pack(side=RIGHT)
excecute_frame.pack()

process_frame = Frame(everything_frame, width=10, height=1)
process_frame.pack()
process_label = Label(process_frame, text="select .out files to be processed")
process_label.pack(side=LEFT)
select_outs_button = Button(process_frame, text="Select Files", command=select_outs, width=20, height=1)
select_outs_button.pack(side=LEFT)
select_outs_label = Label(process_frame, text="0 files selected")
select_outs_label.pack(side=RIGHT)

process_button = Button(everything_frame, text="Process Data", command=button_process)
process_button.pack()

load_plots_button = Button(everything_frame, text="Load Plots", command=load_plots)
load_plots_button.pack()

Erfolg_Label = Label(everything_frame, text="Nothing converted yet")
Erfolg_Label.pack()

graph_frame = Frame(fenster)
graph_frame.pack()
buttons_frame = Frame(graph_frame, height=10)
buttons_frame.pack()
left_button = Button(buttons_frame, text="<-", command=move_left)
number_entry = Entry(buttons_frame)
number_entry.bind("<Return>", update_graph)
right_button = Button(buttons_frame, text="->", command=move_right)
left_button.pack(side=LEFT)
number_entry.pack(side=LEFT)
right_button.pack(side=LEFT)
fig = Figure(figsize=(
    fenster.winfo_screenwidth() / get_dpi(fenster) * 0.8, fenster.winfo_screenheight() / get_dpi(fenster) * 0.2),
    dpi=300)
plot = fig.add_subplot()
label_axes()
plot.plot([0, 1], [0, 0])

canvas = FigureCanvasTkAgg(fig, graph_frame)
canvas.get_tk_widget().pack()
canvas.draw()

# In der Ereignisschleife auf Eingabe des Benutzers warten.
fenster.mainloop()
